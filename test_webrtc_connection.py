#!/usr/bin/env python3\n\"\"\"\nWebRTC连接稳定性测试脚本\n测试修复后的WebRTC连接是否稳定\n\"\"\"\nimport asyncio\nimport aiohttp\nimport json\nimport time\nfrom datetime import datetime\n\nclass WebRTCConnectionTester:\n    def __init__(self, base_url=\"http://localhost:8010\"):\n        self.base_url = base_url\n        self.session = None\n        self.test_results = []\n    \n    async def __aenter__(self):\n        self.session = aiohttp.ClientSession()\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if self.session:\n            await self.session.close()\n    \n    def log_result(self, test_name, success, message=\"\", duration=0):\n        \"\"\"记录测试结果\"\"\"\n        result = {\n            'test': test_name,\n            'success': success,\n            'message': message,\n            'duration': duration,\n            'timestamp': datetime.now().isoformat()\n        }\n        self.test_results.append(result)\n        \n        status = \"✅\" if success else \"❌\"\n        print(f\"{status} {test_name}: {message} ({duration:.2f}s)\")\n    \n    async def test_server_health(self):\n        \"\"\"测试服务器健康状态\"\"\"\n        start_time = time.time()\n        try:\n            async with self.session.get(f\"{self.base_url}/\") as response:\n                success = response.status == 200\n                duration = time.time() - start_time\n                self.log_result(\n                    \"服务器健康检查\", \n                    success, \n                    f\"状态码: {response.status}\", \n                    duration\n                )\n                return success\n        except Exception as e:\n            duration = time.time() - start_time\n            self.log_result(\"服务器健康检查\", False, f\"连接失败: {e}\", duration)\n            return False\n    \n    async def test_webrtc_offer(self):\n        \"\"\"测试WebRTC offer端点\"\"\"\n        start_time = time.time()\n        try:\n            # 模拟一个简单的WebRTC offer\n            offer_data = {\n                \"sdp\": \"v=0\\r\\no=- 123456789 2 IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\na=group:BUNDLE 0 1\\r\\na=extmap-allow-mixed\\r\\na=msid-semantic: WMS\\r\\nm=video 9 UDP/TLS/RTP/SAVPF 96\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:test\\r\\na=ice-pwd:test\\r\\na=ice-options:trickle\\r\\na=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\\r\\na=setup:actpass\\r\\na=mid:0\\r\\na=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\\r\\na=recvonly\\r\\na=rtcp-mux\\r\\na=rtpmap:96 VP8/90000\\r\\nm=audio 9 UDP/TLS/RTP/SAVPF 111\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:test\\r\\na=ice-pwd:test\\r\\na=ice-options:trickle\\r\\na=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\\r\\na=setup:actpass\\r\\na=mid:1\\r\\na=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\\r\\na=recvonly\\r\\na=rtcp-mux\\r\\na=rtpmap:111 opus/48000/2\\r\\n\",\n                \"type\": \"offer\"\n            }\n            \n            async with self.session.post(\n                f\"{self.base_url}/offer\",\n                json=offer_data,\n                headers={'Content-Type': 'application/json'},\n                timeout=15  # 增加超时时间\n            ) as response:\n                duration = time.time() - start_time\n                \n                if response.status == 200:\n                    data = await response.json()\n                    if 'sessionid' in data:\n                        self.log_result(\n                            \"WebRTC Offer\", \n                            True, \n                            f\"会话ID: {data['sessionid']}\", \n                            duration\n                        )\n                        return data['sessionid']\n                    else:\n                        self.log_result(\"WebRTC Offer\", False, \"响应中缺少sessionid\", duration)\n                        return None\n                else:\n                    error_text = await response.text()\n                    self.log_result(\n                        \"WebRTC Offer\", \n                        False, \n                        f\"状态码: {response.status}, 错误: {error_text[:100]}\", \n                        duration\n                    )\n                    return None\n                    \n        except asyncio.TimeoutError:\n            duration = time.time() - start_time\n            self.log_result(\"WebRTC Offer\", False, \"请求超时\", duration)\n            return None\n        except Exception as e:\n            duration = time.time() - start_time\n            self.log_result(\"WebRTC Offer\", False, f\"异常: {e}\", duration)\n            return None\n    \n    async def test_session_heartbeat(self, session_id):\n        \"\"\"测试会话心跳\"\"\"\n        if not session_id:\n            self.log_result(\"会话心跳\", False, \"无有效会话ID\")\n            return False\n        \n        start_time = time.time()\n        try:\n            heartbeat_data = {\"sessionid\": int(session_id)}\n            \n            async with self.session.post(\n                f\"{self.base_url}/session/heartbeat\",\n                json=heartbeat_data,\n                headers={'Content-Type': 'application/json'},\n                timeout=10\n            ) as response:\n                duration = time.time() - start_time\n                \n                if response.status == 200:\n                    data = await response.json()\n                    ttl = data.get('ttl_seconds', 'N/A')\n                    self.log_result(\n                        \"会话心跳\", \n                        True, \n                        f\"TTL: {ttl}秒\", \n                        duration\n                    )\n                    return True\n                else:\n                    error_text = await response.text()\n                    self.log_result(\n                        \"会话心跳\", \n                        False, \n                        f\"状态码: {response.status}, 错误: {error_text[:100]}\", \n                        duration\n                    )\n                    return False\n                    \n        except Exception as e:\n            duration = time.time() - start_time\n            self.log_result(\"会话心跳\", False, f\"异常: {e}\", duration)\n            return False\n    \n    async def test_session_persistence(self, session_id):\n        \"\"\"测试会话持久性\"\"\"\n        if not session_id:\n            self.log_result(\"会话持久性\", False, \"无有效会话ID\")\n            return False\n        \n        print(f\"\\n测试会话 {session_id} 的持久性...\")\n        \n        # 连续发送多次心跳，测试会话是否稳定\n        success_count = 0\n        total_tests = 5\n        \n        for i in range(total_tests):\n            print(f\"  心跳测试 {i+1}/{total_tests}\")\n            if await self.test_session_heartbeat(session_id):\n                success_count += 1\n            \n            # 等待一段时间再发送下一次心跳\n            await asyncio.sleep(2)\n        \n        success_rate = (success_count / total_tests) * 100\n        success = success_rate >= 80  # 80%成功率认为是稳定的\n        \n        self.log_result(\n            \"会话持久性\", \n            success, \n            f\"成功率: {success_rate:.1f}% ({success_count}/{total_tests})\"\n        )\n        \n        return success\n    \n    async def test_connection_stability(self):\n        \"\"\"测试连接稳定性\"\"\"\n        print(\"\\n🔗 测试WebRTC连接稳定性...\")\n        \n        # 创建多个会话测试并发稳定性\n        session_ids = []\n        \n        for i in range(3):  # 创建3个会话\n            print(f\"\\n创建会话 {i+1}/3\")\n            session_id = await self.test_webrtc_offer()\n            if session_id:\n                session_ids.append(session_id)\n                await asyncio.sleep(1)  # 间隔1秒\n        \n        if not session_ids:\n            self.log_result(\"连接稳定性\", False, \"无法创建任何会话\")\n            return False\n        \n        # 测试所有会话的心跳\n        stable_sessions = 0\n        for session_id in session_ids:\n            if await self.test_session_heartbeat(session_id):\n                stable_sessions += 1\n        \n        stability_rate = (stable_sessions / len(session_ids)) * 100\n        success = stability_rate >= 80\n        \n        self.log_result(\n            \"连接稳定性\", \n            success, \n            f\"稳定会话: {stable_sessions}/{len(session_ids)} ({stability_rate:.1f}%)\"\n        )\n        \n        # 清理会话\n        for session_id in session_ids:\n            try:\n                await self.session.post(\n                    f\"{self.base_url}/session/close\",\n                    json={\"sessionid\": int(session_id)},\n                    headers={'Content-Type': 'application/json'},\n                    timeout=5\n                )\n            except:\n                pass  # 忽略清理错误\n        \n        return success\n    \n    async def run_full_test(self):\n        \"\"\"运行完整的连接稳定性测试\"\"\"\n        print(f\"🧪 WebRTC连接稳定性测试 - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        print(\"=\" * 70)\n        \n        # 1. 服务器健康检查\n        if not await self.test_server_health():\n            print(\"❌ 服务器不可用，终止测试\")\n            return False\n        \n        # 2. 基本WebRTC连接测试\n        session_id = await self.test_webrtc_offer()\n        if not session_id:\n            print(\"❌ 无法建立WebRTC连接，终止测试\")\n            return False\n        \n        # 3. 会话心跳测试\n        await self.test_session_heartbeat(session_id)\n        \n        # 4. 会话持久性测试\n        await self.test_session_persistence(session_id)\n        \n        # 5. 连接稳定性测试\n        await self.test_connection_stability()\n        \n        # 清理测试会话\n        try:\n            await self.session.post(\n                f\"{self.base_url}/session/close\",\n                json={\"sessionid\": int(session_id)},\n                headers={'Content-Type': 'application/json'},\n                timeout=5\n            )\n            print(f\"\\n🧹 测试会话 {session_id} 已清理\")\n        except:\n            pass\n        \n        # 统计结果\n        total_tests = len(self.test_results)\n        passed_tests = sum(1 for r in self.test_results if r['success'])\n        \n        print(\"\\n\" + \"=\" * 70)\n        print(f\"📊 测试结果: {passed_tests}/{total_tests} 通过\")\n        \n        if passed_tests == total_tests:\n            print(\"🎉 所有测试通过！WebRTC连接稳定\")\n        else:\n            print(\"⚠️ 部分测试失败，连接可能不稳定\")\n            \n            # 显示失败的测试\n            failed_tests = [r for r in self.test_results if not r['success']]\n            if failed_tests:\n                print(\"\\n❌ 失败的测试:\")\n                for test in failed_tests:\n                    print(f\"   - {test['test']}: {test['message']}\")\n        \n        # 计算稳定性评分\n        stability_score = (passed_tests / total_tests) * 100\n        print(f\"\\n📈 连接稳定性评分: {stability_score:.1f}%\")\n        \n        if stability_score >= 90:\n            print(\"🌟 连接稳定性: 优秀\")\n        elif stability_score >= 80:\n            print(\"👍 连接稳定性: 良好\")\n        elif stability_score >= 70:\n            print(\"⚠️ 连接稳定性: 一般\")\n        else:\n            print(\"❌ 连接稳定性: 需要改进\")\n        \n        return passed_tests == total_tests\n\nasync def main():\n    \"\"\"主函数\"\"\"\n    import sys\n    \n    base_url = \"http://localhost:8010\"\n    if len(sys.argv) > 1:\n        base_url = sys.argv[1]\n    \n    print(f\"测试服务器: {base_url}\")\n    print(\"提示: 可以通过参数指定服务器地址\\n\")\n    \n    async with WebRTCConnectionTester(base_url) as tester:\n        success = await tester.run_full_test()\n        return 0 if success else 1\n\nif __name__ == \"__main__\":\n    try:\n        exit_code = asyncio.run(main())\n        exit(exit_code)\n    except KeyboardInterrupt:\n        print(\"\\n测试被中断\")\n        exit(1)\n    except Exception as e:\n        print(f\"测试异常: {e}\")\n        exit(1)\n"