<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>数字人 RAG 交互平台</title>
    <script src="client.js"></script>
    <style>
        :root {
            --bg-color: #f7f9fc;
            --card-bg: #ffffff;
            --primary-color: #1a73e8;
            --primary-hover: #1867cf;
            --text-color: #202124;
            --subtle-text: #5f6368;
            --border-color: #dadce0;
            --success-color: #1e8e3e;
            --error-color: #d93025;
            --font-family: 'Google Sans', 'Noto Sans SC', 'Roboto', 'Helvetica Neue', sans-serif;
            --border-radius: 8px;
            --shadow: 0 1px 2px 0 rgba(60,64,67,0.3), 0 2px 6px 2px rgba(60,64,67,0.15);
        }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 24px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        .main-container {
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            gap: 24px;
            width: 100%;
            max-width: 1200px;
        }
        .card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        h2, h3 {
            margin: 0;
            font-weight: 500;
        }
        h2 { font-size: 22px; }
        h3 { font-size: 18px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px; }

        .video-container {
            background-color: #000;
            border-radius: var(--border-radius);
            overflow: hidden;
            position: relative;
        }
        /* 直接对目标 video 元素进行样式设置 */
        #video {
            width: 100%;
            display: block;
        }

        .button-group { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        button {
            font-family: var(--font-family);
            padding: 10px 16px;
            border: 1px solid transparent;
            border-radius: var(--border-radius);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        button:disabled { cursor: not-allowed; opacity: 0.6; }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:not(:disabled):hover { background-color: var(--primary-hover); }
        .btn-secondary { background-color: transparent; color: var(--primary-color); border-color: var(--border-color); }
        .btn-secondary:not(:disabled):hover { background-color: rgba(26, 115, 232, 0.05); }
        .btn-danger { background-color: var(--error-color); color: white; }
        .btn-danger:not(:disabled):hover { background-color: #a52714; }

        .form-group { display: flex; flex-direction: column; gap: 8px; }
        label { font-size: 14px; font-weight: 500; color: var(--subtle-text); }
        input[type="text"], input[type="file"], select, textarea {
            width: 100%;
            padding: 10px;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            font-size: 14px;
            box-sizing: border-box;
        }
        input[type="file"] { padding: 5px; }
        textarea { resize: vertical; min-height: 80px; }
        
        .switch-container { display: flex; align-items: center; justify-content: space-between; }
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(20px); }

        .chat-area { flex-grow: 1; display: flex; flex-direction: column; gap: 16px; }
        #chat-output {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 12px;
            min-height: 150px;
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.6;
        }
        .status-bar {
            font-size: 12px; color: var(--subtle-text); padding: 8px; border-radius: var(--border-radius); background-color: var(--bg-color);
        }
        .toast {
            position: fixed; top: 20px; right: 20px; padding: 12px 20px; border-radius: var(--border-radius); color: white; font-weight: 500; z-index: 1000;
            opacity: 0; transition: opacity 0.5s, transform 0.5s; transform: translateY(-20px);
        }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.success { background-color: var(--success-color); }
        .toast.error { background-color: var(--error-color); }
    </style>
</head>
<body>
    <input id="use-stun" type="checkbox" style="display: none;" checked>
    <input type="hidden" id="sessionid">
    
    <audio id="audio" autoplay></audio>

    <div class="main-container">
        <div class="card">
            <h2>数字人预览</h2>
            <div class="video-container">
                <video id="video" autoplay playsinline></video>
            </div>
            <div class="button-group">
                <button id="start" class="btn-primary">开始连接</button>
                <button id="stop" class="btn-danger" style="display: none;">断开连接</button>
                <button id="reconnect" class="btn-secondary" style="display: none;">手动重连</button>
            </div>

            <h3>文本/语音对话</h3>
            <div class="form-group" style="border-top: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color); padding: 16px 0; margin-top:10px;">
                <div class="switch-container">
                    <label for="rag-mode-speak-switch">RAG 模式驱动</label>
                    <label class="switch">
                        <input type="checkbox" id="rag-mode-speak-switch">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="form-group" style="margin-top: 10px;">
                    <label for="kb-speak-select">使用知识库</label>
                    <select id="kb-speak-select">
                        <option value="">无</option>
                    </select>
                </div>
            </div>

            <div class="form-group">
                <textarea id="human-text" placeholder="输入文本，让虚拟人说话..."></textarea>
                <button id="send-human-text" class="btn-secondary">发送文本并朗读</button>
            </div>
            <div class="button-group">
                <button id="start-record" class="btn-secondary">语音对话</button>
                <button id="stop-record" class="btn-danger" style="display: none;">停止录音</button>
            </div>
        </div>

        <div class="card">
            <h2>RAG 知识库交互</h2>
            
            <div class="form-group">
                <label for="chat-input">聊天输入 (不驱动数字人)</label>
                <textarea id="chat-input" placeholder="在此输入您的问题进行测试..."></textarea>
                <button id="send-chat" class="btn-primary">发送查询</button>
            </div>
             <div class="form-group">
                <label for="chat-output">模型响应</label>
                <div id="chat-output"></div>
            </div>

            <h3>数字人管理</h3>
            <div class="form-group">
                <label for="avatar-select">当前数字人</label>
                <div style="display: flex; gap: 10px;">
                    <select id="avatar-select" style="flex-grow: 1;">
                        <option value="">选择数字人</option>
                    </select>
                    <button id="avatar-switch" class="btn-primary">切换数字人</button>
                </div>
                <small id="avatar-status" style="margin-top: 5px; display: block;"></small>
            </div>
            <div class="form-group">
                <label for="avatar-file">上传数字人素材</label>
                <input type="file" id="avatar-file" accept="image/*,video/*,.zip">
                <label for="avatar-id" style="margin-top:10px;">数字人ID (可选，自动生成)</label>
                <input type="text" id="avatar-id" placeholder="如：xiaoli0001 (1-16位拼音+1-4位数字)">
                <button id="avatar-upload" class="btn-secondary" style="margin-top:10px;">创建数字人</button>
            </div>
            <div class="form-group">
                <label for="avatar-delete">删除数字人</label>
                <div style="display: flex; gap: 10px;">
                    <select id="avatar-delete-select" style="flex-grow: 1;">
                        <option value="">选择要删除的数字人</option>
                    </select>
                    <button id="avatar-delete" class="btn-danger">删除</button>
                </div>
            </div>

            <h3>FishTTS 声音克隆</h3>
            <div class="form-group">
                <label for="fishtts-voice-list">可用克隆音源 (用于驱动数字人)</label>
                <div style="display: flex; gap: 10px;">
                    <select id="fishtts-voice-list" style="flex-grow: 1;">
                        <option value="">使用默认音色</option>
                    </select>
                    <button id="delete-fishtts-voice" class="btn-danger">删除</button>
                </div>
                <small id="fishtts-status" style="margin-top: 5px; display: block;"></small>
            </div>
            <div class="form-group">
                <label for="fishtts-voice-name">新音源名称</label>
                <input type="text" id="fishtts-voice-name" placeholder="3-20位英文/数字">
                <label for="fishtts-audio-file" style="margin-top:10px;">上传音频 (WAV/MP3/FLAC, 最大40秒)</label>
                <input type="file" id="fishtts-audio-file" accept="audio/*">
                <button id="upload-fishtts-voice" class="btn-secondary" style="margin-top:10px;">上传新音源</button>
            </div>
            <h3>知识库管理</h3>
            <div class="form-group">
                <label for="kb-select">当前知识库 (全局)</label>
                <div style="display: flex; gap: 10px;">
                    <select id="kb-select" style="flex-grow: 1;">
                        <option value="">无</option>
                    </select>
                    <button id="delete-kb" class="btn-danger">删除</button>
                </div>
            </div>
            <div class="form-group">
                <label for="kb-name">新建知识库</label>
                <input type="text" id="kb-name" placeholder="输入知识库名称 (3-20位英文/数字)">
                <input type="file" id="kb-file">
                <button id="create-kb" class="btn-secondary">创建并上传</button>
            </div>

            <h3>LLM 设置</h3>
            <div class="form-group">
                <label for="llm-provider-select">LLM 提供商</label>
                <div style="display: flex; gap: 10px;">
                    <select id="llm-provider-select" style="flex-grow: 1;">
                        <option value="ollama">Ollama</option>
                        <option value="deepseek">DeepSeek</option>
                    </select>
                    <button id="switch-llm-btn" class="btn-primary">切换</button>
                    <button id="test-llm-btn" class="btn-secondary">测试</button>
                </div>
                <small id="llm-status" style="margin-top: 5px; display: block;">当前: Ollama</small>
            </div>

            <h3>RAG 设置</h3>
            <div class="switch-container">
                <label for="rag-mode-switch">RAG 模式 (全局)</label>
                <label class="switch">
                    <input type="checkbox" id="rag-mode-switch">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="form-group">
                <label for="system-prompt">系统提示词</label>
                <textarea id="system-prompt"></textarea>
                <button id="update-prompt" class="btn-secondary">更新提示词</button>
            </div>
            <div id="status-bar" class="status-bar" style="display: none;"></div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // DOM 元素
        const dom = {
            // 媒体元素
            video: document.getElementById('video'),
            audio: document.getElementById('audio'),

            sessionIdInput: document.getElementById('sessionid'),
            startConnBtn: document.getElementById('start'),
            stopConnBtn: document.getElementById('stop'),
            reconnectBtn: document.getElementById('reconnect'),
            
            // 左侧交互
            sendHumanTextBtn: document.getElementById('send-human-text'),
            humanTextInput: document.getElementById('human-text'),
            startRecordBtn: document.getElementById('start-record'),
            stopRecordBtn: document.getElementById('stop-record'),
            ragModeSpeakSwitch: document.getElementById('rag-mode-speak-switch'),
            kbSpeakSelect: document.getElementById('kb-speak-select'),

            // 右侧交互与配置
            chatInput: document.getElementById('chat-input'),
            sendChatBtn: document.getElementById('send-chat'),
            chatOutput: document.getElementById('chat-output'),
            ragModeSwitch: document.getElementById('rag-mode-switch'),
            systemPrompt: document.getElementById('system-prompt'),
            updatePromptBtn: document.getElementById('update-prompt'),
            kbSelect: document.getElementById('kb-select'),
            deleteKbBtn: document.getElementById('delete-kb'),
            kbNameInput: document.getElementById('kb-name'),
            kbFileInput: document.getElementById('kb-file'),
            createKbBtn: document.getElementById('create-kb'),

            // ★★★ 新增: 数字人 DOM 元素 ★★★
            avatarSelect: document.getElementById('avatar-select'),
            avatarSwitch: document.getElementById('avatar-switch'),
            avatarStatus: document.getElementById('avatar-status'),
            avatarFile: document.getElementById('avatar-file'),
            avatarId: document.getElementById('avatar-id'),
            avatarUpload: document.getElementById('avatar-upload'),
            avatarDeleteSelect: document.getElementById('avatar-delete-select'),
            avatarDelete: document.getElementById('avatar-delete'),

            // ★★★ 新增: FishTTS DOM 元素 ★★★
            fishttsVoiceList: document.getElementById('fishtts-voice-list'),
            fishttsStatus: document.getElementById('fishtts-status'),
            deleteFishttsVoiceBtn: document.getElementById('delete-fishtts-voice'),
            fishttsVoiceNameInput: document.getElementById('fishtts-voice-name'),
            fishttsAudioFileInput: document.getElementById('fishtts-audio-file'),
            uploadFishttsVoiceBtn: document.getElementById('upload-fishtts-voice'),

            // ★★★ 新增: LLM DOM 元素 ★★★
            llmProviderSelect: document.getElementById('llm-provider-select'),
            switchLlmBtn: document.getElementById('switch-llm-btn'),
            testLlmBtn: document.getElementById('test-llm-btn'),
            llmStatus: document.getElementById('llm-status'),

            statusBar: document.getElementById('status-bar'),
            toast: document.getElementById('toast'),
        };

        // 状态变量
        let state = {
            sessionId: null,
            isRecording: false,
            mediaRecorder: null,
            audioChunks: [],
            // ★★★ 新增: 心跳和重连状态 ★★★
            heartbeatInterval: null,
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            isReconnecting: false,
        };

        // --- 工具函数 ---
        function showToast(message, type = 'success') {
            dom.toast.textContent = message;
            dom.toast.className = `toast show ${type}`;
            setTimeout(() => {
                dom.toast.className = 'toast';
            }, 3000);
        }

        function updateStatus(message, isLoading = false) {
            if (message) {
                dom.statusBar.style.display = 'block';
                dom.statusBar.innerHTML = isLoading 
                    ? `<div class="spinner"></div> ${message}`
                    : message;
            } else {
                dom.statusBar.style.display = 'none';
            }
        }

        // --- API 调用 ---
        const api = {
            async fetch(url, options = {}) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({error: '未知错误'}));
                        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                    }
                    // 如果请求方法不是 'DELETE' 或其他不需要body的, 则返回json，否则直接返回response
                    if (options.method === 'DELETE' || response.status === 204) {
                        return response;
                    }
                    return response; // 允许调用者决定如何处理响应
                } catch (error) {
                    showToast(`请求失败: ${error.message}`, 'error');
                    console.error('API Error:', error);
                    throw error;
                }
            },
            
            getConfig: () => api.fetch('/config/get').then(res => res.json()),
            getKbList: () => api.fetch('/kb/list').then(res => res.json()),
            switchKb: (name) => api.fetch(`/kb/switch/${name}`, { method: 'POST' }),
            deleteKb: (name) => api.fetch(`/kb/delete/${name}`, { method: 'DELETE' }),
            createKb: (formData) => api.fetch('/kb/create', { method: 'POST', body: formData }),
            getTaskStatus: (taskId) => api.fetch(`/kb/status/${taskId}`).then(res => res.json()),
            updatePrompt: (prompt) => api.fetch('/config/prompt', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({prompt}) }),
            setRagMode: (use_rag) => api.fetch('/config/rag_mode', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({use_rag}) }),
            ragChat: (query) => api.fetch('/rag/chat', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({query}) }),
            sendHumanText: (payload) => api.fetch('/human', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) }),
            sendHumanAudio: (formData) => api.fetch('/audio_chat', { method: 'POST', body: formData }),
            interruptTalk: (sessionId) => api.fetch('/interrupt_talk', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ sessionid: sessionId }) }),

            // ★★★ 新增: 心跳和重连API ★★★
            sessionHeartbeat: (sessionId) => api.fetch('/session/heartbeat', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ sessionid: Number(sessionId) }) }),
            reconnect: (payload) => api.fetch('/reconnect', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) }),

            // ★★★ 新增: 数字人 API 调用 ★★★
            getAvatars: (page = 1, pageSize = 20) => api.fetch(`/api/avatars?page=${page}&page_size=${pageSize}`).then(res => res.json()),
            getAvatarDetail: (id) => api.fetch(`/api/avatars/${id}`).then(res => res.json()),
            createAvatar: (formData) => api.fetch('/api/avatars', { method: 'POST', body: formData }).then(res => res.json()),
            deleteAvatar: (id) => api.fetch(`/api/avatars/${id}`, { method: 'DELETE' }),
            switchAvatar: (sessionId, avatarId) => api.fetch(`/api/sessions/${sessionId}/avatar`, { 
                method: 'PATCH', 
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ avatar_id: avatarId }) 
            }).then(res => res.json()),
            getTaskStatus: (jobId) => api.fetch(`/api/avatars/tasks/${jobId}`).then(res => res.json()),

            // ★★★ 新增: FishTTS API 调用 ★★★
            // 注意: 这里的API路径/fishtts/voices与后端路由保持一致
            getFishttsVoices: () => api.fetch('/fishtts/voices').then(res => res.json()),
            uploadFishttsVoice: (formData) => api.fetch('/fishtts/voices', { method: 'POST', body: formData }).then(res => res.json()),
            deleteFishttsVoice: (name) => api.fetch(`/fishtts/voices/${name}`, { method: 'DELETE' }),

            // ★★★ 新增: LLM API 调用 ★★★
            getLlmProviders: () => api.fetch('/llm/providers').then(res => res.json()),
            switchLlmProvider: (provider) => api.fetch('/llm/switch', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({provider}) }).then(res => res.json()),
            testLlm: (query = 'Hello, please respond with a simple greeting.') => api.fetch('/llm/test', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({query}) }).then(res => res.json()),
        };

        // --- ★★★ 新增: LLM 核心功能函数 ★★★ ---
        async function loadLlmProviders() {
            try {
                const data = await api.getLlmProviders();
                dom.llmProviderSelect.value = data.current_provider;
                dom.llmStatus.textContent = `当前: ${data.current_provider} (${data.client_info.model || 'N/A'})`;
            } catch (error) {
                console.error("加载LLM提供商失败:", error);
                dom.llmStatus.textContent = '加载LLM状态失败';
            }
        }

        async function handleSwitchLlm() {
            const selectedProvider = dom.llmProviderSelect.value;
            
            // 在切换前先中断当前对话，确保WebRTC稳定
            if (state.sessionId) {
                try {
                    await api.interruptTalk(state.sessionId);
                    console.log('已中断当前对话，准备切换LLM，WebRTC连接保持稳定');
                } catch (e) {
                    console.warn('中断对话失败，继续切换LLM:', e);
                }
            }
            
            try {
                updateStatus('正在切换LLM提供商...', true);
                const result = await api.switchLlmProvider(selectedProvider);
                showToast(`LLM已切换到 ${result.current_provider}`, 'success');
                dom.llmStatus.textContent = `当前: ${result.current_provider} (${result.client_info.model || 'N/A'})`;
                
                // 切换成功后，给一个短暂延迟确保后端状态稳定
                setTimeout(() => {
                    console.log('LLM切换完成，系统已就绪，WebRTC连接未受影响');
                }, 1000);
                
            } catch (error) {
                console.error("切换LLM失败:", error);
                showToast('LLM切换失败，请检查网络连接', 'error');
            } finally {
                updateStatus(null);
            }
        }

        async function handleTestLlm() {
            try {
                updateStatus('正在测试LLM连接...', true);
                const result = await api.testLlm();
                if (result.success) {
                    showToast(`LLM测试成功 (${result.provider})`, 'success');
                } else {
                    showToast(`LLM测试失败: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error("测试LLM失败:", error);
                // showToast 已在 api.fetch 中处理
            } finally {
                updateStatus(null);
            }
        }

        // --- ★★★ 新增: FishTTS 核心功能函数 ★★★ ---
        async function loadFishttsVoices() {
            try {
                const data = await api.getFishttsVoices();
                const voiceList = dom.fishttsVoiceList;
                voiceList.innerHTML = '<option value="">使用默认音色</option>'; // 重置

                if (data.voices && data.voices.length > 0) {
                    data.voices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice;
                        option.textContent = voice;
                        voiceList.appendChild(option);
                    });
                    dom.fishttsStatus.textContent = `仓库中有 ${data.voices.length} 个音源。`;
                } else {
                    dom.fishttsStatus.textContent = '音源仓库为空，将使用默认音色。';
                }
            } catch (error) {
                console.error("加载FishTTS音源失败:", error);
                dom.fishttsStatus.textContent = '加载音源列表失败。';
                // showToast 已在 api.fetch 中处理
            }
        }

        async function handleUploadFishttsVoice() {
            const voiceName = dom.fishttsVoiceNameInput.value.trim();
            const file = dom.fishttsAudioFileInput.files[0];

            if (!voiceName.match(/^[a-zA-Z0-9_]{3,20}$/)) {
                showToast("名称不合法 (3-20位英文/数字/下划线)", 'error');
                return;
            }
            if (!file) {
                showToast("请选择一个音频文件", 'error');
                return;
            }

            const formData = new FormData();
            formData.append('voice_name', voiceName);
            formData.append('audio_file', file);

            updateStatus('正在上传并验证音源...', true);
            try {
                const data = await api.uploadFishttsVoice(formData);
                showToast(`音源 ${data.voice_name} 上传成功!`, 'success');
                dom.fishttsVoiceNameInput.value = '';
                dom.fishttsAudioFileInput.value = '';
                await loadFishttsVoices(); // 重新加载列表
            } catch (e) {
                // api.fetch 中已处理错误 toast
            } finally {
                updateStatus(null);
            }
        }

        async function handleDeleteFishttsVoice() {
            const selectedVoice = dom.fishttsVoiceList.value;
            if (!selectedVoice) {
                showToast("请先选择一个要删除的音源", 'error');
                return;
            }

            if (confirm(`确定要删除音源 "${selectedVoice}" 吗？此操作不可恢复。`)) {
                try {
                    await api.deleteFishttsVoice(selectedVoice);
                    showToast(`音源 ${selectedVoice} 已删除`);
                    await loadFishttsVoices(); // 重新加载列表
                } catch (e) {
                    // api.fetch 中已处理错误 toast
                }
            }
        }

        // --- ★★★ 新增: 数字人核心功能函数 ★★★ ---
        async function loadAvatars() {
            try {
                const data = await api.getAvatars();
                const avatarSelect = dom.avatarSelect;
                const avatarDeleteSelect = dom.avatarDeleteSelect;
                
                // 重置选择框
                avatarSelect.innerHTML = '<option value="">选择数字人</option>';
                avatarDeleteSelect.innerHTML = '<option value="">选择要删除的数字人</option>';

                if (data.avatars && data.avatars.length > 0) {
                    data.avatars.forEach(avatar => {
                        // 为选择框添加选项
                        const selectOption = document.createElement('option');
                        selectOption.value = avatar.avatar_id;
                        selectOption.textContent = `${avatar.avatar_id} (${avatar.frames}帧)`;
                        avatarSelect.appendChild(selectOption);

                        // 为删除框添加选项
                        const deleteOption = document.createElement('option');
                        deleteOption.value = avatar.avatar_id;
                        deleteOption.textContent = `${avatar.avatar_id} (${avatar.frames}帧)`;
                        avatarDeleteSelect.appendChild(deleteOption);
                    });
                    dom.avatarStatus.textContent = `共有 ${data.total} 个数字人。`;
                } else {
                    dom.avatarStatus.textContent = '暂无数字人，请先创建。';
                }
            } catch (error) {
                console.error("加载数字人列表失败:", error);
                dom.avatarStatus.textContent = '加载数字人列表失败。';
            }
        }

        async function handleCreateAvatar() {
            const file = dom.avatarFile.files[0];
            const avatarId = dom.avatarId.value.trim();

            if (!file) {
                showToast("请选择一个文件", 'error');
                return;
            }

            // 验证avatar_id格式（如果提供）
            if (avatarId && !avatarId.match(/^[a-z]{1,16}\d{1,4}$/)) {
                showToast("数字人ID格式不正确，应为1-16位拼音+1-4位数字，如：xiaoli0001", 'error');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);
            if (avatarId) {
                formData.append('avatar_id', avatarId);
            }

            updateStatus('正在创建数字人...', true);
            try {
                const result = await api.createAvatar(formData);
                showToast(`数字人创建任务已提交，任务ID: ${result.job_id}`, 'success');
                
                // 清空表单
                dom.avatarFile.value = '';
                dom.avatarId.value = '';
                
                // 开始轮询任务状态
                pollTaskStatus(result.job_id, result.avatar_id);
                
            } catch (e) {
                // api.fetch 中已处理错误 toast
            } finally {
                updateStatus(null);
            }
        }

        async function pollTaskStatus(jobId, avatarId) {
            const maxAttempts = 60; // 最多轮询60次（5分钟）
            let attempts = 0;
            
            const poll = async () => {
                try {
                    const taskInfo = await api.getTaskStatus(jobId);
                    
                    if (taskInfo.status === 'SUCCEEDED') {
                        showToast(`数字人 ${avatarId} 创建成功！`, 'success');
                        await loadAvatars(); // 重新加载列表
                        return;
                    } else if (taskInfo.status === 'FAILED') {
                        showToast(`数字人 ${avatarId} 创建失败: ${taskInfo.stderr_tail || '未知错误'}`, 'error');
                        return;
                    }
                    
                    // 继续轮询
                    attempts++;
                    if (attempts < maxAttempts) {
                        setTimeout(poll, 5000); // 5秒后再次检查
                    } else {
                        showToast(`数字人 ${avatarId} 创建超时，请稍后检查状态`, 'error');
                    }
                } catch (error) {
                    console.error("轮询任务状态失败:", error);
                    attempts++;
                    if (attempts < maxAttempts) {
                        setTimeout(poll, 5000);
                    }
                }
            };
            
            poll();
        }

        async function handleSwitchAvatar() {
            // 中文注释：读取选择与当前会话ID
            const selectedAvatar = dom.avatarSelect.value;
            const sessionId = state.sessionId;

            if (!selectedAvatar) {
                showToast("请先选择一个数字人", 'error');
                return;
            }
            if (!sessionId) {
                showToast("请先建立WebRTC连接", 'error');
                return;
            }

            try {
                // 先“打断说话”，让后端把 TTS/ASR/渲染等队列清干净（兜底）
                await api.fetch('/interrupt_talk', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ sessionid: sessionId })
                });

                // 再请求切换（后端内部也会再次“先停”，双保险）
                const result = await api.switchAvatar(sessionId, selectedAvatar);

                if (result.error && result.error.includes("会话不存在")) {
                    // 会话丢失：宽限期内试试重连，否则提示重新开始
                    showToast('会话失效，尝试重连...', 'warning');
                    try {
                        await api.fetch('/reconnect', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({ sessionid: sessionId })
                        });
                        showToast('已重连，请再次点击“切换数字人”。', 'success');
                    } catch (re) {
                        showToast('重连失败，请重新建立连接。', 'error');
                    }
                    return;
                }

                showToast(`数字人切换成功: ${result.previous || '无'} -> ${result.current}`, 'success');
                console.log(`数字人切换完成，WebRTC连接保持稳定: ${result.previous || '无'} -> ${result.current}`);
            } catch (e) {
                // 统一错误提示已在 api.fetch 中处理
                console.error(e);
            }
        }

        async function handleDeleteAvatar() {
            const selectedAvatar = dom.avatarDeleteSelect.value;
            
            if (!selectedAvatar) {
                showToast("请先选择一个要删除的数字人", 'error');
                return;
            }

            if (confirm(`确定要删除数字人 "${selectedAvatar}" 吗？此操作不可恢复。`)) {
                try {
                    await api.deleteAvatar(selectedAvatar);
                    showToast(`数字人 ${selectedAvatar} 已删除`);
                    await loadAvatars(); // 重新加载列表
                } catch (e) {
                    // api.fetch 中已处理错误 toast
                }
            }
        }
        
        // --- 核心功能 (部分修改) ---
        async function initializeRAG() {
            try {
                const [config, kbList] = await Promise.all([api.getConfig(), api.getKbList()]);
                
                dom.ragModeSwitch.checked = config.use_rag;
                dom.ragModeSpeakSwitch.checked = config.use_rag;
                dom.systemPrompt.value = config.system_prompt;
                
                const kbOptions = '<option value="">无</option>' + kbList.knowledge_bases.map(kb => `<option value="${kb}">${kb}</option>`).join('');
                dom.kbSelect.innerHTML = kbOptions;
                dom.kbSpeakSelect.innerHTML = kbOptions;
                
                if (config.current_kb) {
                    dom.kbSelect.value = config.current_kb;
                    dom.kbSpeakSelect.value = config.current_kb;
                }

            } catch (error) {
                console.error("初始化RAG配置失败:", error);
                showToast("无法加载RAG配置", 'error');
            }
        }
        
        async function handleCreateKb() {
            const kbName = dom.kbNameInput.value.trim();
            const file = dom.kbFileInput.files[0];

            if (!kbName.match(/^[a-zA-Z0-9]{3,20}$/)) {
                showToast("知识库名称不合法 (3-20位英文/数字)", 'error');
                return;
            }
            if (!file) {
                showToast("请选择要上传的文件", 'error');
                return;
            }
            
            // ★★★ 修改点 1: 扩展允许的文件类型列表 ★★★
            const allowedExtensions = ['.pdf', '.docx', '.doc', '.pptx', '.ppt', '.txt', '.md', '.png', '.jpg', '.jpeg'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
            if (!allowedExtensions.includes(fileExtension)) {
                // ★★★ 修改点 2: 更新用户提示信息 ★★★
                showToast('文件格式不支持。请上传图片、PDF、Word、PPT 或 TXT/MD 文件。', 'error');
                dom.kbFileInput.value = ''; // 重置文件输入
                return;
            }

            const formData = new FormData();
            formData.append('kb_name', kbName);
            formData.append('file', file);
            
            try {
                const response = await api.createKb(formData);
                const data = await response.json();
                showToast('文件上传成功，后台处理中...');
                pollTaskStatus(data.task_id);
            } catch(e) { /* API handler already showed toast */ }
        }

        function pollTaskStatus(taskId) {
            updateStatus(`任务 ${taskId}: 正在处理...`, true);
            const interval = setInterval(async () => {
                try {
                    const status = await api.getTaskStatus(taskId);
                    updateStatus(`任务 ${taskId}: ${status.message}`, status.status === 'processing');
                    if (status.status === 'success') {
                        clearInterval(interval);
                        showToast(status.message, 'success');
                        await initializeRAG();
                        updateStatus(null);
                    } else if (status.status === 'failed') {
                        clearInterval(interval);
                        showToast(status.message, 'error');
                        updateStatus(null);
                    }
                } catch (e) {
                    clearInterval(interval);
                    updateStatus(null);
                }
            }, 3000);
        }
        
        async function handleRagChat() {
            const query = dom.chatInput.value.trim();
            if (!query) return;

            dom.chatOutput.textContent = '';
            dom.sendChatBtn.disabled = true;

            try {
                const response = await api.ragChat(query);
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); 
                    
                    for (const line of lines) {
                        if (line.trim() === '') continue;
                        try {
                            const jsonData = JSON.parse(line);
                            if (jsonData && jsonData.response) {
                                dom.chatOutput.textContent += jsonData.response;
                            }
                        } catch (e) {
                            console.warn("无法解析的JSON行:", line);
                        }
                    }
                }
                if (buffer.trim() !== '') {
                     try {
                        const jsonData = JSON.parse(buffer);
                        if (jsonData && jsonData.response) {
                            dom.chatOutput.textContent += jsonData.response;
                        }
                    } catch (e) {
                        console.warn("无法解析的JSON行 (buffer):", buffer);
                    }
                }
            } catch (e) {
                dom.chatOutput.textContent = `查询失败: ${e.message}`;
            } finally {
                dom.sendChatBtn.disabled = false;
            }
        }

        // ★★★ 修改: handleSendHumanText 函数 ★★★
        async function handleSendHumanText() {
            if (!state.sessionId) {
                showToast('请先连接数字人', 'error');
                return;
            }
            const text = dom.humanTextInput.value.trim();
            if (!text) return;

            // 先发送打断请求
            await api.interruptTalk(state.sessionId).catch(e => console.error("打断请求失败:", e));
            
            const useRag = dom.ragModeSpeakSwitch.checked;
            const kbName = dom.kbSpeakSelect.value;
            // 新增：获取选中的 FishTTS 克隆音源
            const selectedFishttsVoice = dom.fishttsVoiceList.value;

            const payload = {
                sessionid: state.sessionId,
                text: text,
                interrupt: false, // interrupt Talk 已独立发送
                use_rag: useRag,
                kb_name: useRag ? kbName : null,
                type: 'chat',
                tts_options: {} // 始终创建 tts_options 对象
            };
            
            // 如果选中了克隆音源，则添加到 tts_options
            if (selectedFishttsVoice) {
                payload.tts_options.voice_clone_name = selectedFishttsVoice;
            }
            
            try {
                await api.sendHumanText(payload);
            } catch (e) {}
        }

        function connect() {
            dom.startConnBtn.disabled = true;
            dom.startConnBtn.textContent = '连接中...';
            window.start();

            // ★★★ 新增: 监听连接状态变化 ★★★
            if (pc) {
                pc.addEventListener('connectionstatechange', handleConnectionStateChange);
            }

            // 使用更长的轮询间隔，避免过于频繁的检查
            let connectionCheckAttempts = 0;
            const maxConnectionCheckAttempts = 60; // 最多检查60次（30秒）
            
            const interval = setInterval(() => {
                connectionCheckAttempts++;
                
                if (dom.sessionIdInput.value && dom.sessionIdInput.value !== "0") {
                    clearInterval(interval);
                    state.sessionId = dom.sessionIdInput.value;
                    showToast('WebRTC连接成功！');
                    dom.startConnBtn.style.display = 'none';
                    dom.stopConnBtn.style.display = 'block';
                    console.log(`WebRTC连接建立成功，会话ID: ${state.sessionId}`);

                    // 开启心跳，但延迟启动
                    setTimeout(() => {
                        if (state.heartbeatInterval) clearInterval(state.heartbeatInterval);
                        state.heartbeatInterval = setInterval(() => {
                            if (state.sessionId) {
                                api.sessionHeartbeat(state.sessionId).catch(e => console.warn("心跳失败:", e));
                            }
                        }, 30000); // 30秒心跳间隔
                        console.log('心跳监控已启动');
                    }, 5000); // 连接成功5秒后再启动心跳
                    
                } else if (connectionCheckAttempts >= maxConnectionCheckAttempts) {
                    // 超时处理
                    clearInterval(interval);
                    console.error('WebRTC连接超时');
                    showToast('连接超时，请重试', 'error');
                    dom.startConnBtn.disabled = false;
                    dom.startConnBtn.textContent = '开始连接';
                }
            }, 500); // 保持500ms检查间隔，但增加超时机制
        }

        function disconnect() {
            // ★★★ 新增: 停止心跳和重连 ★★★
            if (state.heartbeatInterval) clearInterval(state.heartbeatInterval);
            state.heartbeatInterval = null;
            state.isReconnecting = false;

            if (window.stop) window.stop();
            state.sessionId = null;
            dom.sessionIdInput.value = '';
            showToast('已断开连接');
            dom.startConnBtn.style.display = 'block';
            dom.stopConnBtn.style.display = 'none';
            dom.reconnectBtn.style.display = 'none';
            dom.startConnBtn.disabled = false;
            dom.startConnBtn.textContent = '开始连接';
        }

        // ★★★ 新增: 手动重连功能 ★★★
        async function manualReconnect() {
            if (!state.sessionId) {
                showToast('没有有效的会话 ID，请重新连接', 'error');
                return;
            }

            dom.reconnectBtn.disabled = true;
            dom.reconnectBtn.textContent = '重连中...';
            
            try {
                const success = await tryReconnect();
                if (success) {
                    showToast('重连成功', 'success');
                    dom.reconnectBtn.style.display = 'none';
                } else {
                    showToast('重连失败，请棄网络后再试', 'error');
                }
            } catch (error) {
                console.error('手动重连失败:', error);
                showToast('重连出错，请稍后再试', 'error');
            } finally {
                dom.reconnectBtn.disabled = false;
                dom.reconnectBtn.textContent = '手动重连';
            }
        }

        // ★★★ 优化: WebRTC连接状态处理，减少激进的重连 ★★★
        async function tryReconnect() {
            if (!pc || !state.sessionId) {
                console.log('无法重连：缺少PC实例或会话ID');
                return false;
            }
            
            try {
                console.log('尝试进行 ICE 重启...');
                const offer = await pc.createOffer({ iceRestart: true });
                await pc.setLocalDescription(offer);
                
                const res = await api.reconnect({
                    sessionid: Number(state.sessionId),
                    sdp: offer.sdp,
                    type: offer.type
                });
                const ans = await res.json();
                await pc.setRemoteDescription({ type: ans.type, sdp: ans.sdp });
                console.log('ICE 重启 offer/answer交换完成');
                return true;
            } catch (error) {
                console.error('重连失败:', error);
                return false;
            }
        }

        async function handleDisconnect() {
            // 避免重复重连
            if (state.isReconnecting) {
                console.log('重连已在进行中，跳过');
                return;
            }
            
            state.isReconnecting = true;
            state.reconnectAttempts = 0;
            
            console.log('开始处理连接断开，等待一段时间观察连接状态...');
            
            // 给连接一些时间自然恢复
            await new Promise(r => setTimeout(r, 3000));
            
            // 检查连接是否已经自然恢复
            if (pc && (pc.connectionState === 'connected' || pc.connectionState === 'connecting')) {
                console.log('连接已自然恢复，取消重连');
                state.isReconnecting = false;
                return;
            }

            while (state.reconnectAttempts < state.maxReconnectAttempts && state.isReconnecting) {
                state.reconnectAttempts++;
                console.log(`开始第 ${state.reconnectAttempts}/${state.maxReconnectAttempts} 次重连尝试`);
                showToast(`连接断开, 正在重连 (${state.reconnectAttempts}/${state.maxReconnectAttempts})...`, 'warning');

                try {
                    const success = await tryReconnect();
                    if (success) {
                        // 等待连接状态稳定
                        await new Promise(r => setTimeout(r, 5000));
                        
                        if (pc && pc.connectionState === 'connected') {
                            console.log('重连成功！');
                            showToast('连接已恢复', 'success');
                            state.isReconnecting = false;
                            return;
                        }
                    }
                } catch (error) {
                    console.error(`重连尝试 ${state.reconnectAttempts} 失败:`, error);
                    // 增加重连间隔，避免过于频繁
                    await new Promise(r => setTimeout(r, 5000 * state.reconnectAttempts)); // 递增等待时间
                }
            }

            if (state.isReconnecting) {
                console.log('所有重连尝试都失败了');
                showToast('重连失败, 请手动重新连接', 'error');
                state.isReconnecting = false;
                disconnect();
            }
        }

        function handleConnectionStateChange() {
            if (!pc) return;
            
            const currentState = pc.connectionState;
            console.log(`连接状态变更: ${currentState}`);
            
            switch (currentState) {
                case 'connecting':
                    console.log('WebRTC正在连接...');
                    showToast('正在连接...', 'info');
                    dom.reconnectBtn.style.display = 'none';
                    break;
                case 'connected':
                    console.log('WebRTC连接已建立');
                    if (state.isReconnecting) {
                        showToast('WebRTC连接已恢复', 'success');
                        state.isReconnecting = false;
                        state.reconnectAttempts = 0;
                    } else {
                        showToast('WebRTC连接成功', 'success');
                    }
                    dom.reconnectBtn.style.display = 'none';
                    // 清除心跳监控的倒计时
                    if (state.heartbeatInterval) {
                        clearInterval(state.heartbeatInterval);
                    }
                    // 启动心跳监控
                    state.heartbeatInterval = setInterval(() => {
                        if (state.sessionId) {
                            api.sessionHeartbeat(state.sessionId).catch(e => console.error("心跳失败:", e));
                        }
                    }, 20000); // 每20秒发送一次心跳
                    break;
                case 'disconnected':
                    console.log('WebRTC连接断开，等待用户重连或系统自然恢复...');
                    showToast('连接断开，系统保留会话5分钟，可点击重连按钮', 'warning');
                    dom.reconnectBtn.style.display = 'block';
                    // 不自动重连，等待用户手动操作或系统自然恢复
                    break;
                case 'failed':
                    console.log('WebRTC连接失败');
                    showToast('WebRTC连接失败，请点击重连按钮或检查网络', 'error');
                    dom.reconnectBtn.style.display = 'block';
                    // 不自动断开，等待用户手动操作
                    break;
                case 'closed':
                    console.log('WebRTC连接已关闭');
                    dom.reconnectBtn.style.display = 'none';
                    if (state.heartbeatInterval) {
                        clearInterval(state.heartbeatInterval);
                        state.heartbeatInterval = null;
                    }
                    break;
            }
        }
        
        async function startRecording() {
            if (!state.sessionId) {
                showToast("请先连接数字人", "error");
                return;
            }
            // 先发送打断请求
            await api.interruptTalk(state.sessionId).catch(e => console.error("打断请求失败:", e));

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                state.mediaRecorder = new MediaRecorder(stream);
                state.audioChunks = [];
                state.mediaRecorder.ondataavailable = e => state.audioChunks.push(e.data);
                
                // ★★★ 修改: mediaRecorder.onstop 回调 ★★★
                state.mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(state.audioChunks, { type: 'audio/wav' });
                    const useRag = dom.ragModeSpeakSwitch.checked;
                    const kbName = dom.kbSpeakSelect.value;
                    // 新增：获取选中的 FishTTS 克隆音源
                    const selectedFishttsVoice = dom.fishttsVoiceList.value;

                    const formData = new FormData();
                    formData.append('file', audioBlob, 'recording.wav');
                    formData.append('sessionid', state.sessionId);
                    formData.append('use_rag', String(useRag)); // 布尔值转字符串
                    if (useRag) {
                        formData.append('kb_name', kbName);
                    }
                    
                    // 新增：将 tts_options 作为 JSON 字符串添加
                    const ttsOptions = {};
                    if (selectedFishttsVoice) {
                        ttsOptions.voice_clone_name = selectedFishttsVoice;
                    }
                    formData.append('tts_options', JSON.stringify(ttsOptions));

                    try {
                        await api.sendHumanAudio(formData);
                        showToast('语音已发送处理');
                    } catch(e) {}
                    
                    dom.stopRecordBtn.style.display = 'none';
                    dom.startRecordBtn.style.display = 'block';
                    state.isRecording = false;
                };

                state.mediaRecorder.start();
                state.isRecording = true;
                dom.startRecordBtn.style.display = 'none';
                dom.stopRecordBtn.style.display = 'block';
            } catch (e) {
                showToast('无法访问麦克风', 'error');
            }
        }
        
        function stopRecording() {
            if (state.mediaRecorder && state.isRecording) {
                state.mediaRecorder.stop();
            }
        }

        // --- 事件监听 ---
        dom.startConnBtn.addEventListener('click', connect);
        dom.stopConnBtn.addEventListener('click', disconnect);
        dom.reconnectBtn.addEventListener('click', manualReconnect);
        dom.sendHumanTextBtn.addEventListener('click', handleSendHumanText);
        dom.startRecordBtn.addEventListener('click', startRecording);
        dom.stopRecordBtn.addEventListener('click', stopRecording); // 确保调用停止函数

        dom.sendChatBtn.addEventListener('click', handleRagChat);
        dom.createKbBtn.addEventListener('click', handleCreateKb);
        dom.updatePromptBtn.addEventListener('click', async () => { try { await api.updatePrompt(dom.systemPrompt.value); showToast('提示词更新成功'); } catch(e){} });
        
        dom.kbFileInput.addEventListener('change', () => {
            const file = dom.kbFileInput.files[0];
            if (!file) return;

            // ★★★ 修改点 3: 扩展允许的文件类型列表 ★★★
            const allowedExtensions = ['.pdf', '.docx', '.doc', '.pptx', '.ppt', '.txt', '.md', '.png', '.jpg', '.jpeg'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();

            if (!allowedExtensions.includes(fileExtension)) {
                // ★★★ 修改点 4: 更新用户提示信息 ★★★
                showToast('文件格式不支持。请上传图片、PDF、Word、PPT 或 TXT/MD 文件。', 'error');
                dom.kbFileInput.value = '';
            }
        });

        function syncControls(source, value) {
            if (source === 'ragSwitch') {
                dom.ragModeSpeakSwitch.checked = value;
                dom.ragModeSwitch.checked = value;
            } else if (source === 'kbSelect') {
                dom.kbSpeakSelect.value = value;
                dom.kbSelect.value = value;
            }
        }
        
        dom.ragModeSwitch.addEventListener('change', async (e) => { 
            const isChecked = e.target.checked;
            syncControls('ragSwitch', isChecked);
            try { 
                await api.setRagMode(isChecked); 
                showToast(`RAG模式已${isChecked ? '开启' : '关闭'}`); 
                console.log(`RAG模式已切换为: ${isChecked ? '开启' : '关闭'}，WebRTC连接不受影响`);
            } catch(e){
                console.error('RAG模式切换失败:', e);
                showToast('RAG模式切换失败', 'error');
            } 
        });
        dom.ragModeSpeakSwitch.addEventListener('change', (e) => {
             const isChecked = e.target.checked;
             syncControls('ragSwitch', isChecked);
             dom.ragModeSwitch.dispatchEvent(new Event('change'));
        });

        dom.kbSelect.addEventListener('change', async (e) => {
              const selectedValue = e.target.value;
              syncControls('kbSelect', selectedValue);
              if (!selectedValue && selectedValue !== "") return; // 允许选择 "无"
              try { await api.switchKb(selectedValue); showToast(selectedValue ? `知识库已切换为 ${selectedValue}` : '已取消使用知识库'); } catch(e){}
        });
        dom.kbSpeakSelect.addEventListener('change', (e) => {
            const selectedValue = e.target.value;
            syncControls('kbSelect', selectedValue);
            dom.kbSelect.dispatchEvent(new Event('change'));
        });
        
        dom.deleteKbBtn.addEventListener('click', async () => {
            const selectedKb = dom.kbSelect.value;
            if (!selectedKb) { showToast('请选择一个知识库', 'error'); return; }
            if (confirm(`确定要删除知识库 "${selectedKb}" 吗？此操作不可恢复。`)) {
                try {
                    await api.deleteKb(selectedKb);
                    showToast(`知识库 ${selectedKb} 已删除`);
                    await initializeRAG();
                } catch(e){}
            }
        });

        // ★★★ 新增: 绑定新按钮的事件 ★★★
        dom.uploadFishttsVoiceBtn.addEventListener('click', handleUploadFishttsVoice);
        dom.deleteFishttsVoiceBtn.addEventListener('click', handleDeleteFishttsVoice);

        // ★★★ 新增: 绑定数字人按钮的事件 ★★★
        dom.avatarUpload.addEventListener('click', handleCreateAvatar);
        dom.avatarSwitch.addEventListener('click', handleSwitchAvatar);
        dom.avatarDelete.addEventListener('click', handleDeleteAvatar);

        // ★★★ 新增: 绑定LLM按钮的事件 ★★★
        dom.switchLlmBtn.addEventListener('click', handleSwitchLlm);
        dom.testLlmBtn.addEventListener('click', handleTestLlm);

        // --- 页面初始化 ---
        initializeRAG();
        loadFishttsVoices(); // ★★★ 新增: 页面加载时获取音源列表
        loadAvatars(); // ★★★ 新增: 页面加载时获取数字人列表
        loadLlmProviders(); // ★★★ 新增: 页面加载时获取LLM提供商列表
    });
</script>
</body>
</html>