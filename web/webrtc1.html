<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>数字人 RAG 交互平台</title>
    <script src="client.js"></script>
    <style>
        :root {
            --bg-color: #f7f9fc;
            --card-bg: #ffffff;
            --primary-color: #1a73e8;
            --primary-hover: #1867cf;
            --text-color: #202124;
            --subtle-text: #5f6368;
            --border-color: #dadce0;
            --success-color: #1e8e3e;
            --error-color: #d93025;
            --font-family: 'Google Sans', 'Noto Sans SC', 'Roboto', 'Helvetica Neue', sans-serif;
            --border-radius: 8px;
            --shadow: 0 1px 2px 0 rgba(60,64,67,0.3), 0 2px 6px 2px rgba(60,64,67,0.15);
        }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 24px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        .main-container {
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            gap: 24px;
            width: 100%;
            max-width: 1200px;
        }
        .card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        h2, h3 {
            margin: 0;
            font-weight: 500;
        }
        h2 { font-size: 22px; }
        h3 { font-size: 18px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px; }

        .video-container {
            background-color: #000;
            border-radius: var(--border-radius);
            overflow: hidden;
            position: relative;
        }
        /* 直接对目标 video 元素进行样式设置 */
        #video {
            width: 100%;
            display: block;
        }

        .button-group { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        button {
            font-family: var(--font-family);
            padding: 10px 16px;
            border: 1px solid transparent;
            border-radius: var(--border-radius);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        button:disabled { cursor: not-allowed; opacity: 0.6; }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:not(:disabled):hover { background-color: var(--primary-hover); }
        .btn-secondary { background-color: transparent; color: var(--primary-color); border-color: var(--border-color); }
        .btn-secondary:not(:disabled):hover { background-color: rgba(26, 115, 232, 0.05); }
        .btn-danger { background-color: var(--error-color); color: white; }
        .btn-danger:not(:disabled):hover { background-color: #a52714; }

        .form-group { display: flex; flex-direction: column; gap: 8px; }
        label { font-size: 14px; font-weight: 500; color: var(--subtle-text); }
        input[type="text"], input[type="file"], select, textarea {
            width: 100%;
            padding: 10px;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            font-size: 14px;
            box-sizing: border-box;
        }
        input[type="file"] { padding: 5px; }
        textarea { resize: vertical; min-height: 80px; }
        
        .switch-container { display: flex; align-items: center; justify-content: space-between; }
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(20px); }

        .chat-area { flex-grow: 1; display: flex; flex-direction: column; gap: 16px; }
        #chat-output {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 12px;
            min-height: 150px;
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.6;
        }
        .status-bar {
            font-size: 12px; color: var(--subtle-text); padding: 8px; border-radius: var(--border-radius); background-color: var(--bg-color);
        }
        .toast {
            position: fixed; top: 20px; right: 20px; padding: 12px 20px; border-radius: var(--border-radius); color: white; font-weight: 500; z-index: 1000;
            opacity: 0; transition: opacity 0.5s, transform 0.5s; transform: translateY(-20px);
        }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.success { background-color: var(--success-color); }
        .toast.error { background-color: var(--error-color); }
    </style>
</head>
<body>
    <input id="use-stun" type="checkbox" style="display: none;" checked>
    <input type="hidden" id="sessionid">
    
    <audio id="audio" autoplay></audio>

    <div class="main-container">
        <div class="card">
            <h2>数字人预览</h2>
            <div class="video-container">
                <video id="video" autoplay playsinline></video>
            </div>
            <div class="button-group">
                <button id="start" class="btn-primary">开始连接</button>
                <button id="stop" class="btn-danger" style="display: none;">断开连接</button>
            </div>

            <h3>文本/语音对话</h3>
            <div class="form-group" style="border-top: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color); padding: 16px 0; margin-top:10px;">
                <div class="switch-container">
                    <label for="rag-mode-speak-switch">RAG 模式驱动</label>
                    <label class="switch">
                        <input type="checkbox" id="rag-mode-speak-switch">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="form-group" style="margin-top: 10px;">
                    <label for="kb-speak-select">使用知识库</label>
                    <select id="kb-speak-select">
                        <option value="">无</option>
                    </select>
                </div>
            </div>

            <div class="form-group">
                <textarea id="human-text" placeholder="输入文本，让虚拟人说话..."></textarea>
                <button id="send-human-text" class="btn-secondary">发送文本并朗读</button>
            </div>
            <div class="button-group">
                <button id="start-record" class="btn-secondary">语音对话</button>
                <button id="stop-record" class="btn-danger" style="display: none;">停止录音</button>
            </div>
        </div>

        <div class="card">
            <h2>RAG 知识库交互</h2>
            
            <div class="form-group">
                <label for="chat-input">聊天输入 (不驱动数字人)</label>
                <textarea id="chat-input" placeholder="在此输入您的问题进行测试..."></textarea>
                <button id="send-chat" class="btn-primary">发送查询</button>
            </div>
             <div class="form-group">
                <label for="chat-output">模型响应</label>
                <div id="chat-output"></div>
            </div>

            <h3>FishTTS 声音克隆</h3>
            <div class="form-group">
                <label for="fishtts-voice-list">可用克隆音源 (用于驱动数字人)</label>
                <div style="display: flex; gap: 10px;">
                    <select id="fishtts-voice-list" style="flex-grow: 1;">
                        <option value="">使用默认音色</option>
                    </select>
                    <button id="delete-fishtts-voice" class="btn-danger">删除</button>
                </div>
                <small id="fishtts-status" style="margin-top: 5px; display: block;"></small>
            </div>
            <div class="form-group">
                <label for="fishtts-voice-name">新音源名称</label>
                <input type="text" id="fishtts-voice-name" placeholder="3-20位英文/数字">
                <label for="fishtts-audio-file" style="margin-top:10px;">上传音频 (WAV/MP3/FLAC, 最大40秒)</label>
                <input type="file" id="fishtts-audio-file" accept="audio/*">
                <button id="upload-fishtts-voice" class="btn-secondary" style="margin-top:10px;">上传新音源</button>
            </div>
            <h3>知识库管理</h3>
            <div class="form-group">
                <label for="kb-select">当前知识库 (全局)</label>
                <div style="display: flex; gap: 10px;">
                    <select id="kb-select" style="flex-grow: 1;">
                        <option value="">无</option>
                    </select>
                    <button id="delete-kb" class="btn-danger">删除</button>
                </div>
            </div>
            <div class="form-group">
                <label for="kb-name">新建知识库</label>
                <input type="text" id="kb-name" placeholder="输入知识库名称 (3-20位英文/数字)">
                <input type="file" id="kb-file">
                <button id="create-kb" class="btn-secondary">创建并上传</button>
            </div>

            <h3>RAG 设置</h3>
            <div class="switch-container">
                <label for="rag-mode-switch">RAG 模式 (全局)</label>
                <label class="switch">
                    <input type="checkbox" id="rag-mode-switch">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="form-group">
                <label for="system-prompt">系统提示词</label>
                <textarea id="system-prompt"></textarea>
                <button id="update-prompt" class="btn-secondary">更新提示词</button>
            </div>
            <div id="status-bar" class="status-bar" style="display: none;"></div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // DOM 元素
        const dom = {
            // 媒体元素
            video: document.getElementById('video'),
            audio: document.getElementById('audio'),

            sessionIdInput: document.getElementById('sessionid'),
            startConnBtn: document.getElementById('start'),
            stopConnBtn: document.getElementById('stop'),
            
            // 左侧交互
            sendHumanTextBtn: document.getElementById('send-human-text'),
            humanTextInput: document.getElementById('human-text'),
            startRecordBtn: document.getElementById('start-record'),
            stopRecordBtn: document.getElementById('stop-record'),
            ragModeSpeakSwitch: document.getElementById('rag-mode-speak-switch'),
            kbSpeakSelect: document.getElementById('kb-speak-select'),

            // 右侧交互与配置
            chatInput: document.getElementById('chat-input'),
            sendChatBtn: document.getElementById('send-chat'),
            chatOutput: document.getElementById('chat-output'),
            ragModeSwitch: document.getElementById('rag-mode-switch'),
            systemPrompt: document.getElementById('system-prompt'),
            updatePromptBtn: document.getElementById('update-prompt'),
            kbSelect: document.getElementById('kb-select'),
            deleteKbBtn: document.getElementById('delete-kb'),
            kbNameInput: document.getElementById('kb-name'),
            kbFileInput: document.getElementById('kb-file'),
            createKbBtn: document.getElementById('create-kb'),

            // ★★★ 新增: FishTTS DOM 元素 ★★★
            fishttsVoiceList: document.getElementById('fishtts-voice-list'),
            fishttsStatus: document.getElementById('fishtts-status'),
            deleteFishttsVoiceBtn: document.getElementById('delete-fishtts-voice'),
            fishttsVoiceNameInput: document.getElementById('fishtts-voice-name'),
            fishttsAudioFileInput: document.getElementById('fishtts-audio-file'),
            uploadFishttsVoiceBtn: document.getElementById('upload-fishtts-voice'),

            statusBar: document.getElementById('status-bar'),
            toast: document.getElementById('toast'),
        };

        // 状态变量
        let state = {
            sessionId: null,
            isRecording: false,
            mediaRecorder: null,
            audioChunks: [],
            // ★★★ 新增: 心跳和重连状态 ★★★
            heartbeatInterval: null,
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            isReconnecting: false,
        };

        // --- 工具函数 ---
        function showToast(message, type = 'success') {
            dom.toast.textContent = message;
            dom.toast.className = `toast show ${type}`;
            setTimeout(() => {
                dom.toast.className = 'toast';
            }, 3000);
        }

        function updateStatus(message, isLoading = false) {
            if (message) {
                dom.statusBar.style.display = 'block';
                dom.statusBar.innerHTML = isLoading 
                    ? `<div class="spinner"></div> ${message}`
                    : message;
            } else {
                dom.statusBar.style.display = 'none';
            }
        }

        // --- API 调用 ---
        const api = {
            async fetch(url, options = {}) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({error: '未知错误'}));
                        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                    }
                    // 如果请求方法不是 'DELETE' 或其他不需要body的, 则返回json，否则直接返回response
                    if (options.method === 'DELETE' || response.status === 204) {
                        return response;
                    }
                    return response; // 允许调用者决定如何处理响应
                } catch (error) {
                    showToast(`请求失败: ${error.message}`, 'error');
                    console.error('API Error:', error);
                    throw error;
                }
            },
            
            getConfig: () => api.fetch('/config/get').then(res => res.json()),
            getKbList: () => api.fetch('/kb/list').then(res => res.json()),
            switchKb: (name) => api.fetch(`/kb/switch/${name}`, { method: 'POST' }),
            deleteKb: (name) => api.fetch(`/kb/delete/${name}`, { method: 'DELETE' }),
            createKb: (formData) => api.fetch('/kb/create', { method: 'POST', body: formData }),
            getTaskStatus: (taskId) => api.fetch(`/kb/status/${taskId}`).then(res => res.json()),
            updatePrompt: (prompt) => api.fetch('/config/prompt', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({prompt}) }),
            setRagMode: (use_rag) => api.fetch('/config/rag_mode', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({use_rag}) }),
            ragChat: (query) => api.fetch('/rag/chat', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({query}) }),
            sendHumanText: (payload) => api.fetch('/human', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) }),
            sendHumanAudio: (formData) => api.fetch('/audio_chat', { method: 'POST', body: formData }),
            interruptTalk: (sessionId) => api.fetch('/interrupt_talk', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ sessionid: sessionId }) }),

            // ★★★ 新增: 心跳和重连API ★★★
            sessionHeartbeat: (sessionId) => api.fetch('/session/heartbeat', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ sessionid: Number(sessionId) }) }),
            reconnect: (payload) => api.fetch('/reconnect', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) }),

            // ★★★ 新增: FishTTS API 调用 ★★★
            // 注意: 这里的API路径/fishtts/voices与后端路由保持一致
            getFishttsVoices: () => api.fetch('/fishtts/voices').then(res => res.json()),
            uploadFishttsVoice: (formData) => api.fetch('/fishtts/voices', { method: 'POST', body: formData }).then(res => res.json()),
            deleteFishttsVoice: (name) => api.fetch(`/fishtts/voices/${name}`, { method: 'DELETE' }),
        };

        // --- ★★★ 新增: FishTTS 核心功能函数 ★★★ ---
        async function loadFishttsVoices() {
            try {
                const data = await api.getFishttsVoices();
                const voiceList = dom.fishttsVoiceList;
                voiceList.innerHTML = '<option value="">使用默认音色</option>'; // 重置

                if (data.voices && data.voices.length > 0) {
                    data.voices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice;
                        option.textContent = voice;
                        voiceList.appendChild(option);
                    });
                    dom.fishttsStatus.textContent = `仓库中有 ${data.voices.length} 个音源。`;
                } else {
                    dom.fishttsStatus.textContent = '音源仓库为空，将使用默认音色。';
                }
            } catch (error) {
                console.error("加载FishTTS音源失败:", error);
                dom.fishttsStatus.textContent = '加载音源列表失败。';
                // showToast 已在 api.fetch 中处理
            }
        }

        async function handleUploadFishttsVoice() {
            const voiceName = dom.fishttsVoiceNameInput.value.trim();
            const file = dom.fishttsAudioFileInput.files[0];

            if (!voiceName.match(/^[a-zA-Z0-9_]{3,20}$/)) {
                showToast("名称不合法 (3-20位英文/数字/下划线)", 'error');
                return;
            }
            if (!file) {
                showToast("请选择一个音频文件", 'error');
                return;
            }

            const formData = new FormData();
            formData.append('voice_name', voiceName);
            formData.append('audio_file', file);

            updateStatus('正在上传并验证音源...', true);
            try {
                const data = await api.uploadFishttsVoice(formData);
                showToast(`音源 ${data.voice_name} 上传成功!`, 'success');
                dom.fishttsVoiceNameInput.value = '';
                dom.fishttsAudioFileInput.value = '';
                await loadFishttsVoices(); // 重新加载列表
            } catch (e) {
                // api.fetch 中已处理错误 toast
            } finally {
                updateStatus(null);
            }
        }

        async function handleDeleteFishttsVoice() {
            const selectedVoice = dom.fishttsVoiceList.value;
            if (!selectedVoice) {
                showToast("请先选择一个要删除的音源", 'error');
                return;
            }

            if (confirm(`确定要删除音源 "${selectedVoice}" 吗？此操作不可恢复。`)) {
                try {
                    await api.deleteFishttsVoice(selectedVoice);
                    showToast(`音源 ${selectedVoice} 已删除`);
                    await loadFishttsVoices(); // 重新加载列表
                } catch (e) {
                    // api.fetch 中已处理错误 toast
                }
            }
        }
        
        // --- 核心功能 (部分修改) ---
        async function initializeRAG() {
            try {
                const [config, kbList] = await Promise.all([api.getConfig(), api.getKbList()]);
                
                dom.ragModeSwitch.checked = config.use_rag;
                dom.ragModeSpeakSwitch.checked = config.use_rag;
                dom.systemPrompt.value = config.system_prompt;
                
                const kbOptions = '<option value="">无</option>' + kbList.knowledge_bases.map(kb => `<option value="${kb}">${kb}</option>`).join('');
                dom.kbSelect.innerHTML = kbOptions;
                dom.kbSpeakSelect.innerHTML = kbOptions;
                
                if (config.current_kb) {
                    dom.kbSelect.value = config.current_kb;
                    dom.kbSpeakSelect.value = config.current_kb;
                }

            } catch (error) {
                console.error("初始化RAG配置失败:", error);
                showToast("无法加载RAG配置", 'error');
            }
        }
        
        async function handleCreateKb() {
            const kbName = dom.kbNameInput.value.trim();
            const file = dom.kbFileInput.files[0];

            if (!kbName.match(/^[a-zA-Z0-9]{3,20}$/)) {
                showToast("知识库名称不合法 (3-20位英文/数字)", 'error');
                return;
            }
            if (!file) {
                showToast("请选择要上传的文件", 'error');
                return;
            }
            
            const allowedExtensions = ['.pdf', '.docx', '.doc', '.pptx', '.ppt', '.txt', '.md'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
            if (!allowedExtensions.includes(fileExtension)) {
                showToast('文件格式不支持。请上传 PDF, Word, PPT, 或 TXT/MD 文件。', 'error');
                dom.kbFileInput.value = ''; // 重置文件输入
                return;
            }

            const formData = new FormData();
            formData.append('kb_name', kbName);
            formData.append('file', file);
            
            try {
                const response = await api.createKb(formData);
                const data = await response.json();
                showToast('文件上传成功，后台处理中...');
                pollTaskStatus(data.task_id);
            } catch(e) { /* API handler already showed toast */ }
        }

        function pollTaskStatus(taskId) {
            updateStatus(`任务 ${taskId}: 正在处理...`, true);
            const interval = setInterval(async () => {
                try {
                    const status = await api.getTaskStatus(taskId);
                    updateStatus(`任务 ${taskId}: ${status.message}`, status.status === 'processing');
                    if (status.status === 'success') {
                        clearInterval(interval);
                        showToast(status.message, 'success');
                        await initializeRAG();
                        updateStatus(null);
                    } else if (status.status === 'failed') {
                        clearInterval(interval);
                        showToast(status.message, 'error');
                        updateStatus(null);
                    }
                } catch (e) {
                    clearInterval(interval);
                    updateStatus(null);
                }
            }, 3000);
        }
        
        async function handleRagChat() {
            const query = dom.chatInput.value.trim();
            if (!query) return;

            dom.chatOutput.textContent = '';
            dom.sendChatBtn.disabled = true;

            try {
                const response = await api.ragChat(query);
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); 
                    
                    for (const line of lines) {
                        if (line.trim() === '') continue;
                        try {
                            const jsonData = JSON.parse(line);
                            if (jsonData && jsonData.response) {
                                dom.chatOutput.textContent += jsonData.response;
                            }
                        } catch (e) {
                            console.warn("无法解析的JSON行:", line);
                        }
                    }
                }
                if (buffer.trim() !== '') {
                     try {
                        const jsonData = JSON.parse(buffer);
                        if (jsonData && jsonData.response) {
                            dom.chatOutput.textContent += jsonData.response;
                        }
                    } catch (e) {
                        console.warn("无法解析的JSON行 (buffer):", buffer);
                    }
                }
            } catch (e) {
                dom.chatOutput.textContent = `查询失败: ${e.message}`;
            } finally {
                dom.sendChatBtn.disabled = false;
            }
        }

        // ★★★ 修改: handleSendHumanText 函数 ★★★
        async function handleSendHumanText() {
            if (!state.sessionId) {
                showToast('请先连接数字人', 'error');
                return;
            }
            const text = dom.humanTextInput.value.trim();
            if (!text) return;

            // 先发送打断请求
            await api.interruptTalk(state.sessionId).catch(e => console.error("打断请求失败:", e));
            
            const useRag = dom.ragModeSpeakSwitch.checked;
            const kbName = dom.kbSpeakSelect.value;
            // 新增：获取选中的 FishTTS 克隆音源
            const selectedFishttsVoice = dom.fishttsVoiceList.value;

            const payload = {
                sessionid: state.sessionId,
                text: text,
                interrupt: false, // interrupt Talk 已独立发送
                use_rag: useRag,
                kb_name: useRag ? kbName : null,
                type: 'chat',
                tts_options: {} // 始终创建 tts_options 对象
            };
            
            // 如果选中了克隆音源，则添加到 tts_options
            if (selectedFishttsVoice) {
                payload.tts_options.voice_clone_name = selectedFishttsVoice;
            }
            
            try {
                await api.sendHumanText(payload);
            } catch (e) {}
        }

        function connect() {
            dom.startConnBtn.disabled = true;
            dom.startConnBtn.textContent = '连接中...';
            window.start();

            // ★★★ 新增: 监听连接状态变化 ★★★
            if (pc) {
                pc.addEventListener('connectionstatechange', handleConnectionStateChange);
            }

            const interval = setInterval(() => {
                if (dom.sessionIdInput.value && dom.sessionIdInput.value !== "0") {
                    clearInterval(interval);
                    state.sessionId = dom.sessionIdInput.value;
                    showToast('连接成功！');
                    dom.startConnBtn.style.display = 'none';
                    dom.stopConnBtn.style.display = 'block';

                    // ★★★ 新增: 开启心跳 ★★★
                    if (state.heartbeatInterval) clearInterval(state.heartbeatInterval);
                    state.heartbeatInterval = setInterval(() => {
                        if (state.sessionId) {
                            api.sessionHeartbeat(state.sessionId).catch(e => console.error("心跳失败:", e));
                        }
                    }, 20000);
                }
            }, 500);
        }

        function disconnect() {
            // ★★★ 新增: 停止心跳和重连 ★★★
            if (state.heartbeatInterval) clearInterval(state.heartbeatInterval);
            state.heartbeatInterval = null;
            state.isReconnecting = false;

            if (window.stop) window.stop();
            state.sessionId = null;
            dom.sessionIdInput.value = '';
            showToast('已断开连接');
            dom.startConnBtn.style.display = 'block';
            dom.stopConnBtn.style.display = 'none';
            dom.startConnBtn.disabled = false;
            dom.startConnBtn.textContent = '开始连接';
        }

        // ★★★ 新增: WebRTC连接状态处理与重连逻辑 ★★★
        async function tryReconnect() {
            if (!pc || !state.sessionId) return;
            
            console.log('尝试进行 ICE 重启...');
            const offer = await pc.createOffer({ iceRestart: true });
            await pc.setLocalDescription(offer);
            
            const res = await api.reconnect({
                sessionid: Number(state.sessionId),
                sdp: offer.sdp,
                type: offer.type
            });
            const ans = await res.json();
            await pc.setRemoteDescription({ type: ans.type, sdp: ans.sdp });
            console.log('ICE 重启 offer/answer交换完成');
        }

        async function handleDisconnect() {
            state.isReconnecting = true;
            state.reconnectAttempts = 0;

            while (state.reconnectAttempts < state.maxReconnectAttempts && state.isReconnecting) {
                state.reconnectAttempts++;
                showToast(`连接断开, 正在进行第 ${state.reconnectAttempts}/${state.maxReconnectAttempts} 次重连...`, 'error');

                try {
                    await tryReconnect();
                    await new Promise(r => setTimeout(r, 4000)); // 等待4秒看连接是否恢复

                    if (pc && pc.connectionState === 'connected') {
                        return; // 成功，退出循环
                    }
                } catch (error) {
                    console.error(`重连尝试 ${state.reconnectAttempts} 失败:`, error);
                    await new Promise(r => setTimeout(r, 2000)); // 失败后等待2秒
                }
            }

            if (state.isReconnecting) {
                showToast('重连失败, 请手动连接。', 'error');
                disconnect();
            }
        }

        function handleConnectionStateChange() {
            if (!pc) return;
            console.log(`连接状态变更: ${pc.connectionState}`);
            switch (pc.connectionState) {
                case 'connected':
                    if (state.isReconnecting) {
                        showToast('WebRTC 连接已恢复', 'success');
                    }
                    state.isReconnecting = false;
                    state.reconnectAttempts = 0;
                    break;
                case 'disconnected':
                    if (!state.isReconnecting) {
                        handleDisconnect();
                    }
                    break;
                case 'failed':
                    showToast('连接彻底失败, 请手动重新连接。', 'error');
                    state.isReconnecting = false;
                    disconnect();
                    break;
            }
        }
        
        async function startRecording() {
            if (!state.sessionId) {
                showToast("请先连接数字人", "error");
                return;
            }
            // 先发送打断请求
            await api.interruptTalk(state.sessionId).catch(e => console.error("打断请求失败:", e));

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                state.mediaRecorder = new MediaRecorder(stream);
                state.audioChunks = [];
                state.mediaRecorder.ondataavailable = e => state.audioChunks.push(e.data);
                
                // ★★★ 修改: mediaRecorder.onstop 回调 ★★★
                state.mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(state.audioChunks, { type: 'audio/wav' });
                    const useRag = dom.ragModeSpeakSwitch.checked;
                    const kbName = dom.kbSpeakSelect.value;
                    // 新增：获取选中的 FishTTS 克隆音源
                    const selectedFishttsVoice = dom.fishttsVoiceList.value;

                    const formData = new FormData();
                    formData.append('file', audioBlob, 'recording.wav');
                    formData.append('sessionid', state.sessionId);
                    formData.append('use_rag', String(useRag)); // 布尔值转字符串
                    if (useRag) {
                        formData.append('kb_name', kbName);
                    }
                    
                    // 新增：将 tts_options 作为 JSON 字符串添加
                    const ttsOptions = {};
                    if (selectedFishttsVoice) {
                        ttsOptions.voice_clone_name = selectedFishttsVoice;
                    }
                    formData.append('tts_options', JSON.stringify(ttsOptions));

                    try {
                        await api.sendHumanAudio(formData);
                        showToast('语音已发送处理');
                    } catch(e) {}
                    
                    dom.stopRecordBtn.style.display = 'none';
                    dom.startRecordBtn.style.display = 'block';
                    state.isRecording = false;
                };

                state.mediaRecorder.start();
                state.isRecording = true;
                dom.startRecordBtn.style.display = 'none';
                dom.stopRecordBtn.style.display = 'block';
            } catch (e) {
                showToast('无法访问麦克风', 'error');
            }
        }
        
        function stopRecording() {
            if (state.mediaRecorder && state.isRecording) {
                state.mediaRecorder.stop();
            }
        }

        // --- 事件监听 ---
        dom.startConnBtn.addEventListener('click', connect);
        dom.stopConnBtn.addEventListener('click', disconnect);
        dom.sendHumanTextBtn.addEventListener('click', handleSendHumanText);
        dom.startRecordBtn.addEventListener('click', startRecording);
        dom.stopRecordBtn.addEventListener('click', stopRecording); // 确保调用停止函数

        dom.sendChatBtn.addEventListener('click', handleRagChat);
        dom.createKbBtn.addEventListener('click', handleCreateKb);
        dom.updatePromptBtn.addEventListener('click', async () => { try { await api.updatePrompt(dom.systemPrompt.value); showToast('提示词更新成功'); } catch(e){} });
        
        dom.kbFileInput.addEventListener('change', () => {
            const file = dom.kbFileInput.files[0];
            if (!file) return;

            const allowedExtensions = ['.pdf', '.docx', '.doc', '.pptx', '.ppt', '.txt', '.md'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();

            if (!allowedExtensions.includes(fileExtension)) {
                showToast('文件格式不支持。请上传 PDF, Word, PPT, 或 TXT/MD 文件。', 'error');
                dom.kbFileInput.value = '';
            }
        });

        function syncControls(source, value) {
            if (source === 'ragSwitch') {
                dom.ragModeSpeakSwitch.checked = value;
                dom.ragModeSwitch.checked = value;
            } else if (source === 'kbSelect') {
                dom.kbSpeakSelect.value = value;
                dom.kbSelect.value = value;
            }
        }
        
        dom.ragModeSwitch.addEventListener('change', async (e) => { 
            const isChecked = e.target.checked;
            syncControls('ragSwitch', isChecked);
            try { await api.setRagMode(isChecked); showToast(`RAG模式已${isChecked ? '开启' : '关闭'}`); } catch(e){} 
        });
        dom.ragModeSpeakSwitch.addEventListener('change', (e) => {
             const isChecked = e.target.checked;
             syncControls('ragSwitch', isChecked);
             dom.ragModeSwitch.dispatchEvent(new Event('change'));
        });

        dom.kbSelect.addEventListener('change', async (e) => {
              const selectedValue = e.target.value;
              syncControls('kbSelect', selectedValue);
              if (!selectedValue && selectedValue !== "") return; // 允许选择 "无"
              try { await api.switchKb(selectedValue); showToast(selectedValue ? `知识库已切换为 ${selectedValue}` : '已取消使用知识库'); } catch(e){}
        });
        dom.kbSpeakSelect.addEventListener('change', (e) => {
            const selectedValue = e.target.value;
            syncControls('kbSelect', selectedValue);
            dom.kbSelect.dispatchEvent(new Event('change'));
        });
        
        dom.deleteKbBtn.addEventListener('click', async () => {
            const selectedKb = dom.kbSelect.value;
            if (!selectedKb) { showToast('请选择一个知识库', 'error'); return; }
            if (confirm(`确定要删除知识库 "${selectedKb}" 吗？此操作不可恢复。`)) {
                try {
                    await api.deleteKb(selectedKb);
                    showToast(`知识库 ${selectedKb} 已删除`);
                    await initializeRAG();
                } catch(e){}
            }
        });

        // ★★★ 新增: 绑定新按钮的事件 ★★★
        dom.uploadFishttsVoiceBtn.addEventListener('click', handleUploadFishttsVoice);
        dom.deleteFishttsVoiceBtn.addEventListener('click', handleDeleteFishttsVoice);

        // --- 页面初始化 ---
        initializeRAG();
        loadFishttsVoices(); // ★★★ 新增: 页面加载时获取音源列表
    });
</script>
</body>
</html>